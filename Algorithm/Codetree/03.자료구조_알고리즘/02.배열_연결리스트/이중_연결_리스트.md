# ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸

ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸(Doubly Linked List)ëŠ” ì–‘ë°©í–¥ìœ¼ë¡œ ì—°ê²°ëœ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤. ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì™€ ë‹¬ë¦¬ ê° ë…¸ë“œê°€ ì•ì˜ ë…¸ë“œì™€ ë’¤ì˜ ë…¸ë“œ ì–‘ìª½ì„ ëª¨ë‘ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.


## ğŸ§± êµ¬ì¡°
ê° ë…¸ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì •ë³´ë¥¼ ê°€ì§‘ë‹ˆë‹¤:

```py
[ prev | data | next ]
```
- prev: ì´ì „ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
- data: ì €ì¥ëœ ì‹¤ì œ ê°’
- next: ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°


## ğŸ“Œ íŠ¹ì§•
| í•­ëª©              | ì„¤ëª…                                               |
|-------------------|----------------------------------------------------|
| ì–‘ë°©í–¥ íƒìƒ‰ ê°€ëŠ¥   | `prev`, `next` í¬ì¸í„°ë¥¼ í†µí•´ ì•/ë’¤ë¡œ ëª¨ë‘ ì´ë™ ê°€ëŠ¥ |
| ì‚½ì…/ì‚­ì œê°€ ìœ ì—°í•¨ | ë…¸ë“œ ì‚¬ì´ì— ì‰½ê²Œ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°í•  ìˆ˜ ìˆìŒ         |
| ë©”ëª¨ë¦¬ ì‚¬ìš© ì¦ê°€   | í¬ì¸í„°ê°€ 2ê°œ í•„ìš”í•˜ë¯€ë¡œ ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ ë©”ëª¨ë¦¬ë¥¼ ë” ì‚¬ìš©í•¨ |
| êµ¬í˜„ì´ ë³µì¡í•¨     | í¬ì¸í„°ë¥¼ ë” ë§ì´ ë‹¤ë¤„ì•¼ í•˜ë¯€ë¡œ ì½”ë“œê°€ ë” ë³µì¡í•¨     |


## ğŸ”§ ì£¼ìš” ì—°ì‚°

### 1. ì‚½ì…
- ì•ì— ì‚½ì… (push_front)
- ë’¤ì— ì‚½ì… (push_back)
- ì¤‘ê°„ ì‚½ì… (ë…¸ë“œ A ë’¤ì— B ì‚½ì…)

### 2. ì‚­ì œ
- íŠ¹ì • ë…¸ë“œ ì‚­ì œ
- ì•/ë’¤ ì‚­ì œ

### 3. íƒìƒ‰
- ì•â†’ë’¤ ë˜ëŠ” ë’¤â†’ì•ìœ¼ë¡œ ìˆœíšŒ ê°€ëŠ¥


## ì˜ˆì‹œ
### js
```js
class Node {
  constructor(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
  }

  append(data) {
    const newNode = new Node(data);
    if (!this.head) {
      this.head = this.tail = newNode;
    } else {
      this.tail.next = newNode;
      newNode.prev = this.tail;
      this.tail = newNode;
    }
  }

  delete(data) {
    let current = this.head;
    while (current) {
      if (current.data === data) {
        if (current.prev) current.prev.next = current.next;
        else this.head = current.next;
        
        if (current.next) current.next.prev = current.prev;
        else this.tail = current.prev;
        return;
      }
      current = current.next;
    }
  }

  printForward() {
    let current = this.head;
    while (current) {
      console.log(current.data);
      current = current.next;
    }
  }

  printBackward() {
    let current = this.tail;
    while (current) {
      console.log(current.data);
      current = current.prev;
    }
  }
}
```

### py
```py
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current.prev:
                    current.prev.next = current.next
                else:
                    self.head = current.next

                if current.next:
                    current.next.prev = current.prev
                else:
                    self.tail = current.prev
                return
            current = current.next

    def print_forward(self):
        current = self.head
        while current:
            print(current.data)
            current = current.next

    def print_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev
```

### c
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
} Node;

Node* head = NULL;
Node* tail = NULL;

Node* createNode(int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->prev = node->next = NULL;
    return node;
}

void append(int data) {
    Node* node = createNode(data);
    if (head == NULL) {
        head = tail = node;
    } else {
        tail->next = node;
        node->prev = tail;
        tail = node;
    }
}

void delete(int data) {
    Node* current = head;
    while (current) {
        if (current->data == data) {
            if (current->prev)
                current->prev->next = current->next;
            else
                head = current->next;

            if (current->next)
                current->next->prev = current->prev;
            else
                tail = current->prev;

            free(current);
            return;
        }
        current = current->next;
    }
}

void printForward() {
    Node* current = head;
    while (current) {
        printf("%d\n", current->data);
        current = current->next;
    }
}

void printBackward() {
    Node* current = tail;
    while (current) {
        printf("%d\n", current->data);
        current = current->prev;
    }
}
```

## ğŸ§­ ì‚¬ìš© ì˜ˆì‹œ
- ì›¹ ë¸Œë¼ìš°ì €ì˜ ì•/ë’¤ ì´ë™ (ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸°)
- Undo / Redo ì‹œìŠ¤í…œ
- ë°ì´í„° ìºì‹œ (LRU Cache ë“±)
