# State Mutation(상태 변경)

- State mutation이란 기존의 상태 객체(state)를 **직접 변경(수정)**하는 것을 말합니다.
- Redux에서는 **절대 상태를 직접 수정해서는 안 되며, 반드시 **불변성(immutability)**을 유지해야 합니다.


### 🔥 왜 상태 변이를 하면 안 되는가?
| 이유                        | 설명                                                                 |
|-----------------------------|----------------------------------------------------------------------|
| 예측 가능성 감소            | 직접 수정하면 이전 상태와 다음 상태를 비교할 수 없게 됨              |
| 변경 감지 실패              | Redux는 상태 객체의 참조(reference)를 비교해 변경 여부를 판단함      |
| 디버깅/히스토리 트래킹 불가 | 상태를 직접 수정하면 time travel debugging 등이 불가능해짐           |


### ✅ 올바른 상태 변경 방식 (불변성 유지)
```js
// ❌ 잘못된 방식: 기존 객체를 직접 수정
state.value = 1;

// ✅ 올바른 방식: 새로운 객체를 만들어 반환
return {
  ...state,
  value: 1,
};
```

- 또는 Redux Toolkit에서는 immer가 내장되어 있어서 아래처럼 mutable하게 써도 내부적으로 불변성이 유지됩니다:
```js
// Redux Toolkit (createSlice 안에서)
state.value = 1; // 가능하지만 실제로는 불변성 유지됨
```

### 🧠 상태 불변성 패턴 예시
| 상황          | 불변성 유지 예시                                                          |
|---------------|---------------------------------------------------------------------------|
| 객체 변경     | `newState = { ...state, key: newValue }`                                  |
| 배열 추가     | `newState = [ ...state, newItem ]`                                        |
| 배열 삭제     | `newState = state.filter(item => item.id !== idToRemove)`                 |
| 배열 수정     | `newState = state.map(item => item.id === id ? { ...item, x: y } : item)` |


### ⚙️ Redux Toolkit에서의 state mutation 처리
| 기능                 | 설명                                                                  |
|----------------------|-----------------------------------------------------------------------|
| `createSlice()` 내부 | 내부적으로 immer를 사용해 상태를 직접 변경하는 코드도 안전하게 처리함 |
| 코드 간결화          | 복잡한 spread 문법 없이도 상태 변경이 가능함                          |
